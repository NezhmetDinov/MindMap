<!DOCTYPE html>
<html lang="en">
<head>

<title>Combined Mind Map</title>
<link rel="stylesheet" href="css/app.css" type="text/css">

<script type="text/javascript">
<!--

var majKW1 = 'Habitat for Humanity';
var words1 = ['Caring', 'Helping', 'People', 'Safety', 'Security', 'Shelter', 'Community', 'Volunteering'];
var sources1 = ['Habitat for Humanity', 'Habitat for Humanity', 'Habitat for Humanity', 'Habitat for Humanity', 'Habitat for Humanity', 'Habitat for Humanity', 'Habitat for Humanity', 'Habitat for Humanity', 'Helping', 'Community', 'Caring', 'Safety', 'Security'];
var targets1 = ['Caring', 'Helping', 'People', 'Safety', 'Security', 'Shelter', 'Community', 'Volunteering', 'Community', 			'Volunteering', 'People', 'Security', 'Shelter'];

var majKW2 = 'Starbucks';
var words2 = ['Coffee', 'Tea', 'Chai', 'Milk Tea', 'Mocha', 'Drink', 'Smoothy', 'Milk', 'Cappuccino'];
var sources2 = ['Starbucks', 'Starbucks', 'Starbucks', 'Starbucks', 'Starbucks', 'Starbucks', 'Starbucks', 'Starbucks', 'Starbucks', 'Coffee', 'Smoothy', 'Drink', 'Milk Tea', 'Tea'];
var targets2 = ['Coffee', 'Tea', 'Chai', 'Milk Tea', 'Mocha', 'Drink', 'Smoothy', 'Milk', 'Cappuccino', 'Milk', 'Drink', 'Mocha', 'Chai', 'Coffee'];

var nodes = [], lastNodeId, links = [], path = [], force = [];

function indexOfElem(elem) {
	for (var i = 1; i < nodes.length; i++) {
		if (nodes[i].id === elem)
			return i;
	}
}

function loadFromArray() {
	document.getElementById('th1').innerHTML = majKW1;
	document.getElementById('th2').innerHTML = majKW2;
	document.getElementById('ta1').value = words1.join('\n');
	document.getElementById('ta2').value = words2.join('\n');
	document.getElementById('midPanel').removeChild(document.getElementById('loadBtn'));
	document.getElementById('drawBtn').style.visibility = "visible";
}

function move() {
	document.getElementById('ta1').style.display = "none";
	document.getElementById('ta2').style.display = "none";
	document.getElementById('th1').style.visibility = "hidden";
	document.getElementById('th2').style.visibility = "hidden";
	document.getElementById('leftPanel').removeChild(document.getElementById('drawBtn'));
	document.getElementById('midPanel').removeChild(document.getElementById('insWE'));
	document.getElementById('showLinks').style.visibility = "visible";

	sources1.splice(0, words1.length);
	targets1.splice(0, words1.length);
	sources2.splice(0, words2.length);
	targets2.splice(0, words2.length);

	words1.splice(0, words1.length);
	var lines1 = document.getElementById('ta1').value.split(/\n/);
	for (var i = 0; i < lines1.length; i++) {
	  // only push this line if it contains a non whitespace character.
	  if (/\S/.test(lines1[i])) {
		words1.push(lines1[i]);
	  }
	}

	words2.splice(0, words2.length);
	var lines2 = document.getElementById('ta2').value.split(/\n/);
	for (var i = 0; i < lines2.length; i++) {
	  // only push this line if it contains a non whitespace character.
	  if (/\S/.test(lines2[i])) {
		words2.push(lines2[i]);
	  }
	}

	for (var i = 0; i < sources1.length; i++) {
		if (words1.indexOf(sources1[i]) === -1) {
			sources1.splice(i, 1);
			targets1.splice(i, 1);
		}
	}

	for (var i = 0; i < targets1.length; i++) {
		if (words1.indexOf(targets1[i]) === -1) {
			targets1.splice(i, 1);
			sources1.splice(i, 1);
		}
	}

	for (var i = 0; i < sources2.length; i++) {
		if (words2.indexOf(sources2[i]) === -1) {
			sources2.splice(i, 1);
			targets2.splice(i, 1);
		}
	}

	for (var i = 0; i < targets2.length; i++) {
		if (words2.indexOf(targets2[i]) === -1) {
			targets2.splice(i, 1);
			sources2.splice(i, 1);
		}
	}

	document.getElementById('showLinks').innerHTML = words1 + "<br />" + sources1 + "<br />" + targets1 + "<br /><br />" + words2 +
													 "<br />" + sources2 + "<br />" + targets2;
	drawCMM();
}

function drawCMM() {
	document.getElementById('insCW').style.visibility = "visible";

// set up SVG for D3
var width  = window.innerWidth,
 height = window.innerHeight,
  colors = d3.scale.category10();

var svg = d3.select('body')
  .append('svg')
  .attr('width', width)
  .attr('height', height);

// set up initial nodes and links
//  - nodes are known by 'id', not by index in array.
//  - reflexive edges are indicated on the node (as a bold black circle).
//  - links are always source < target; edge directions are set by 'left' and 'right'.

nodes.push({"id": majKW1, "reflexive": true, "colour": "#007FFF", "radius": 60});

for (var i = 0; i < words1.length; i++) {
	nodes.push({"id": words1[i], "reflexive": true, "colour": "#AAA", "radius": 40});
}

nodes.push({"id": majKW2, "reflexive": true, "colour": "#007FFF", "radius": 60});

for (var j = 0; j < words2.length; j++) {
	nodes.push({"id": words2[j], "reflexive": true, "colour": "#AAA", "radius": 40});
}

lastNodeId = nodes[nodes.length];

for (var i = 1; i <= words1.length; i++) {
	links.push({"source": nodes[0], "target": nodes[i], "left": false, "right": false, "colour": "#000", "length": 250});
}

for (var j = words1.length + 1, k = j + 1; k < nodes.length; k++) {
	links.push({"source": nodes[j], "target": nodes[k], "left": false, "right": false, "colour": "#000", "length": 250});
}

if (sources1.length !== 0) {
	for (var i = 0; i < sources1.length; i++) {
			links.push({"source": nodes[indexOfElem(sources1[i])], "target": nodes[indexOfElem(targets1[i])], "left": false, "right": false, "colour": "#000", "length": 250});
	}
}

if (sources2.length !== 0) {
	for (var i = 0; i < sources2.length; i++) {
			links.push({"source": nodes[indexOfElem(sources2[i])], "target": nodes[indexOfElem(targets2[i])], "left": false, "right": false, "colour": "#000", "length": 250});
	}
}

var node_drag = d3.behavior.drag()
        .on('dragstart', dragstart)
        .on('drag', dragmove)
        .on('dragend', dragend);

    function dragstart() {
        force.stop(); // stops the force auto positioning before you start dragging
    }

    function dragmove(d) {
        d.px += d3.event.dx;
        d.py += d3.event.dy;
        d.x += d3.event.dx;
        d.y += d3.event.dy;
    }

    function dragend(d) {
        d.fixed = true; // of course set the node to fixed so the force doesn't include the node in its auto positioning stuff
    }

// init D3 force layout
force = d3.layout.force()
    .nodes(nodes)
    .links(links)
    .size([width, height])
    .linkDistance(250)
    .charge(-500)
    .on('tick', tick)

// define arrow markers for graph links
svg.append('svg:defs').append('svg:marker')
    .attr('id', 'end-arrow')
    .attr('viewBox', '0 -5 10 10')
    .attr('refX', 6)
    .attr('markerWidth', 3)
    .attr('markerHeight', 3)
    .attr('orient', 'auto')
  	.append('svg:path')
    .attr('d', 'M0,-5L10,0L0,5')
    .attr('fill', '#000');

svg.append('svg:defs').append('svg:marker')
    .attr('id', 'start-arrow')
    .attr('viewBox', '0 -5 10 10')
    .attr('refX', 4)
    .attr('markerWidth', 3)
    .attr('markerHeight', 3)
    .attr('orient', 'auto')
  	.append('svg:path')
    .attr('d', 'M10,-5L0,0L10,5')
    .attr('fill', '#000');

// line displayed when dragging new nodes
var drag_line = svg.append('svg:path')
  .attr('class', 'link dragline hidden')
  .attr('d', 'M0,0L0,0');

// handles to link and node element groups
path = svg.append('svg:g').selectAll('path'),
    circle = svg.append('svg:g').selectAll('g');

// mouse event vars
var selected_node = null,
    selected_link = null,
    mousedown_link = null,
    mousedown_node = null,
    mouseup_node = null;

function resetMouseVars() {
  mousedown_node = null;
  mouseup_node = null;
  mousedown_link = null;
}

// update force layout (called automatically each iteration)
function tick() {
  // draw directed edges with proper padding from node centers
  path.attr('d', function(d) {
    var deltaX = d.target.x - d.source.x,
        deltaY = d.target.y - d.source.y,
        dist = Math.sqrt(deltaX * deltaX + deltaY * deltaY),
        normX = deltaX / dist,
        normY = deltaY / dist,
        sourcePadding = d.left ? 17 : 12,
        targetPadding = d.right ? 17 : 12,
        sourceX = d.source.x + (sourcePadding * normX),
        sourceY = d.source.y + (sourcePadding * normY),
        targetX = d.target.x - (targetPadding * normX),
        targetY = d.target.y - (targetPadding * normY);
    return 'M' + sourceX + ',' + sourceY + 'L' + targetX + ',' + targetY;
  });

  circle.attr('transform', function(d) {
    return 'translate(' + d.x + ',' + d.y + ')';
  });
}

// update graph (called when needed)
function restart() {
  // path (link) group
  path = path.data(links);


  // update existing links
  path.classed('selected', function(d) { return d === selected_link; })
    .style('marker-start', function(d) { return d.left ? 'url(#start-arrow)' : ''; })
    .style('marker-end', function(d) { return d.right ? 'url(#end-arrow)' : ''; });


  // add new links
  path.enter().append('svg:path')
    .attr('class', 'link')
    .classed('selected', function(d) { return d === selected_link; })
    .style('marker-start', function(d) { return d.left ? 'url(#start-arrow)' : ''; })
    .style('marker-end', function(d) { return d.right ? 'url(#end-arrow)' : ''; })
    .on('mousedown', function(d) {
      if(d3.event.ctrlKey) return;

      // select link
      mousedown_link = d;
      if(mousedown_link === selected_link) selected_link = null;
      else selected_link = mousedown_link;
      selected_node = null;
      restart();
    });

  // remove old links
  path.exit().remove();

  // circle (node) group
  // NB: the function arg is crucial here! nodes are known by id, not by index!
  circle = circle.data(nodes, function(d) { return d.id; });

  // update existing nodes (reflexive & selected visual states)
  circle.selectAll('circle')
    .style('fill', function(d) { return (d === selected_node) ? d3.rgb(d.colour).brighter().toString() : d.colour; })
    .classed('reflexive', function(d) { return d.reflexive; });

  // add new nodes
  var g = circle.enter().append('svg:g');

  g.append('svg:circle')
    .attr('class', 'node')
    .attr('r', function(d){return d.radius;})
    .style('fill', function(d) { return (d === selected_node) ?   d3.rgb(d.colour).brighter().toString() : d.colour; })
    .style('stroke', function(d) { return "#000" })
    .classed('reflexive', function(d) { return d.reflexive; })
	.call(node_drag)
    .on('mouseover', function(d) {
      if(!mousedown_node || d === mousedown_node) return;
      // enlarge target node
      d3.select(this).attr('transform', '');
    })
    .on('mouseout', function(d) {
      if(!mousedown_node || d === mousedown_node) return;
      // unenlarge target node
      d3.select(this).attr('transform', '');
    })
    .on('mousedown', function(d) {
      if(d3.event.ctrlKey) return;

      // select node
      mousedown_node = d;
      if(mousedown_node === selected_node) selected_node = null;
      else selected_node = mousedown_node;
      selected_link = null;

      // reposition drag line
      drag_line
        .style('marker-end', 'url(#end-arrow)')
        .classed('hidden', false)
        .attr('d', 'M' + mousedown_node.x + ',' + mousedown_node.y + 'L' + mousedown_node.x + ',' + mousedown_node.y);

      restart();
    })
    .on('mouseup', function(d) {
      if(!mousedown_node) return;

      // needed by FF
      drag_line
        .classed('hidden', true)
        .style('marker-end', '');

      // check for drag-to-self
      mouseup_node = d;
      if(mouseup_node === mousedown_node) { resetMouseVars(); return; }

	  // disallow links between two major keywords
	  if(mouseup_node.id === majKW1 && mousedown_node.id === majKW2) { resetMouseVars(); return; }
	  if(mouseup_node.id === majKW2 && mousedown_node.id === majKW1) { resetMouseVars(); return; }

      // unenlarge target node
      d3.select(this).attr('transform', '');

      // add link to graph (update if exists)
      // NB: links are strictly source < target; arrows separately specified by booleans
      var source, target, direction;
      if(mousedown_node.id < mouseup_node.id) {
        source = mousedown_node;
        target = mouseup_node;
        direction = '';
      } else {
        source = mouseup_node;
        target = mousedown_node;
        direction = '';
      }

      var link;
      link = links.filter(function(l) {
        return (l.source === source && l.target === target);
      })[0];

      if(link) {
        link[direction] = true;
      } else {
        link = {"source": source, "target": target, "left": false, "right": false, "colour": "#000", "length": 250};
        link[direction] = true;
        links.push(link);
      }

      // select new link
      selected_link = link;
      selected_node = null;
      restart();
    });

  // show node IDs
  g.append('svg:text')
      .attr('x', 0)
      .attr('dy', '.35em')
	  .attr('text-anchor', 'middle')
      .attr('class', 'id')
      .text(function(d) { return d.id; });

  // remove old nodes
  circle.exit().remove();

  // set the graph in motion
  force.start();
}

function mousedown() {
  svg.classed('active', true);
  if(d3.event.ctrlKey || mousedown_node || mousedown_link) return;
  restart();
}

function mousemove() {
  if(!mousedown_node) return;

  // update drag line
  drag_line.attr('d', 'M' + mousedown_node.x + ',' + mousedown_node.y + 'L' + d3.mouse(this)[0] + ',' + d3.mouse(this)[1]);

  restart();
}

function mouseup() {
  if(mousedown_node) {
    // hide drag line
    drag_line
      .classed('hidden', true)
      .style('marker-end', '');
  }

  // because :active only works in WebKit?
  svg.classed('active', false);

  // clear mouse event vars
  resetMouseVars();
}

function spliceLinksForNode(node) {
  var toSplice = links.filter(function(l) {
    return (l.source === node || l.target === node);
  });
  toSplice.map(function(l) {
    links.splice(links.indexOf(l), 1);
  });
}

// only respond once per keydown
var lastKeyDown = -1;

function keydown() {
  d3.event.preventDefault();

  if(lastKeyDown !== -1) return;
  lastKeyDown = d3.event.keyCode;

  // ctrl
  if(d3.event.keyCode === 17) {
    circle.call(force.drag);
    svg.classed('ctrl', true);
  }

  if(!selected_node && !selected_link) return;
  switch(d3.event.keyCode) {
    case 8: // backspace
    case 46: // delete
      if(selected_node) {
        nodes.splice(nodes.indexOf(selected_node), 1);
        spliceLinksForNode(selected_node);
      } else if(selected_link) {
        links.splice(links.indexOf(selected_link), 1);
      }
      selected_link = null;
      selected_node = null;
      restart();
      break;
    case 66: // B
      if(selected_link) {
        // set link direction to both left and right
        selected_link.left = true;
        selected_link.right = true;
      }
      restart();
      break;
    case 76: // L
      if(selected_link) {
        // set link direction to left only
        selected_link.left = true;
        selected_link.right = false;
      }
      restart();
      break;
    case 82: // R
      if(selected_node) {
        // toggle node reflexivity
        selected_node.reflexive = !selected_node.reflexive;
      } else if(selected_link) {
        // set link direction to right only
        selected_link.left = false;
        selected_link.right = true;
      }
      restart();
      break;
  }
}

function keyup() {
  lastKeyDown = -1;

  // ctrl
  if(d3.event.keyCode === 17) {
    circle
      .on('mousedown.drag', null)
      .on('touchstart.drag', null);
    svg.classed('ctrl', false);
  }
}

// app starts here
svg.on('mousedown', mousedown)
  .on('mousemove', mousemove)
  .on('mouseup', mouseup);
d3.select(window)
  .on('keydown', keydown)
  .on('keyup', keyup);
restart();
}

// -->
</script>

    <style type="text/css">
    <!--
     #insWE {
		border: 2px solid #a1a1a1;
		background: #dddddd;
		width: 60%;
		border-radius: 15px;
		margin-left:30em;
	 }
	 #insCW {
		border: 2px solid #a1a1a1;
		background: #dddddd;
		width: 60%;
		border-radius: 15px;
	 }
    -->
    </style>

</head>

<body>
	<script src="js/d3.v3.min.js"></script>

    <div id="leftPanel">
        <div id="th1" style="color:red; font-weight:bold; font-size:20px;"></div>
        <div id="th2" style="color:red; font-weight:bold; font-size:20px; margin-left:13.5em;"></div>
        <textarea id="ta1" rows="30" style="float:left;"></textarea>
        <textarea id="ta2" rows="30" style="float:left; margin-left:5em;"></textarea>
        <button class="btn" id="drawBtn" onClick="move()" style="visibility:hidden; margin-left:30em;"><h4 style="display:inline">Draw Combined Mind Map</h4></button>
    </div>

    <div id="midPanel" align="center">
        <button id="loadBtn" onClick="loadFromArray()"><h4 style="display:inline">Load Words</h4></button><br /><br />

        <div id="insWE" style="font-size:14px;">
            <p style="color:red; font-weight:bold;">Instructions</p>
            <p>To begin, click on "Load Words" above and put your cursor at the end of last word on the list, press "Enter" key and begin typing <b>to add words</b> to the list. <b>To delete words</b> highlight the word and press "Delete" key.</p>
            <p>When you are done entering the words, click on "Draw Combined Mind Map" below.</p>
        </div><br />

        <div id="showLinks" style="visibility:hidden;"></div>
        <div id="insCW" style="visibility:hidden; font-size:14px;">
            <p style="color:red; font-weight:bold;">Instructions</p>
            <p>To <b>connect concepts</b>, click on a word in a circle and drag it to another word. To <b>delete a concept</b>, click on the circle and press "Delete" key. To delete a connection, click on it till it turns dotted and press "Delete" key.</p>
            <p>If your <b>screen is crowded</b>, you can space things out by clicking and dragging the circles. To do that, click on the gray circle to turn it white. Press and hold the "Ctrl" key on PC (or "Command" key on Mac) and drag the circle.</p>
        </div>
    </div>
</body>
</html>
